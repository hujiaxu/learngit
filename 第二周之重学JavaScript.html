<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601935 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="781"/>

<div>
<span><div><div>一，JS语言通识</div><ul><li><div>泛用语言分类方法</div></li><ul><li><div>语言按语法分类</div></li><ul><li><div>非形式语言</div></li><ul><li><div>自然语言</div></li></ul><li><div>形式语言</div></li><ul><li><div>大部分计算机语言</div></li><li><div>形式语言按照乔姆斯基谱系分为四种类型（以下四种文法呈上下包含关系）</div></li><ol><li><div>0型：无限制文法</div></li><li><div>1型：上下文相关文法</div></li><li><div>2型：上下文无关文法</div></li><li><div>3型：正则文法</div></li></ol></ul></ul></ul><li><div>什么是产生式：巴克斯范式（BNF），是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言</div></li><ul><li><div>BNF规定的推导规则：&lt;非终结符&gt; ::= &lt;使用符号的表达式&gt;。表达式是由一个符号序列，或用指示选择的竖线‘|’分隔多个符号序列构成，每个符号序列整体都是左端符号的一种可能的替代。从未在左端出现的符号叫做<span style="color: rgb(255, 0, 0); font-weight: bold;">终结符</span></div></li><li><div>*表示重复多次。|表示或。+ 表示至少出现一次</div></li></ul><li><div>深入理解产生式</div></li><ul><li><div>通过产生式理解乔姆斯基谱系</div></li><ul><li><div>0型 无限制文法：? ::= ?</div></li><li><div>1型 上下文相关文法：?&lt;A&gt;？::= ?&lt;B&gt;?</div></li><li><div>2型 上下文无关文法：&lt;A&gt; ::= ?</div></li><li><div>3型 正则文法：&lt;A&gt; ::= &lt;A&gt;?</div></li></ul></ul><li><div>现代语言的分类</div></li><ul><li><div>按用途分类</div></li><ul><li><div>数据描述语言：Json,HTML,XAML，SQL，CSS</div></li><li><div>编程语言：C语言，C++，Java，C#，Python，Ruby，Perl，Lisp，T-SQL，Clojure，Haskell，Javascript</div></li></ul><li><div>按表达方式分类：</div></li><ul><li><div>声明式语言：Json,HTML,XAML，SQL，CSS，Lisp，Clojure，Haskell。</div></li><li><div>命令式语言：C语言，C++，Java，C#，Python，Ruby，Perl，JavaScript</div></li></ul><li><div>动态语言和静态语言：</div></li><ul><li><div>动态语言：程序运行期间才给变量制定数据的类型：Object-C，C#，Javascript，PHP，Python，Erlang</div></li><li><div>  静态语言：在写程序代码的时候就要定制数据的类型：C语言，Java，C++。</div></li></ul><li><div>编译型语言和解释性语言：</div></li><ul><li><div>  编译型语言：将所有源代码编译成机器码才能执行的语言：C语言，C++，Pascal，Object-C。</div></li><li><div>  解释型语言：在程序运行的时候对语句进行逐行翻译：Javascript，Python，Erlang,PHP,Perl，Ruby。</div></li></ul><li><div>强类型语言弱类型语言：</div></li><ul><li><div>  强类型语言：一个变量被指定了某种类型，只能通过强制类型转换才能转换成其他数据类型的语言：Java，C#，Python，Object-C，Ruby。</div></li><li><div>  弱类型语言：数据类型几乎可以被忽略的语言：Javascript，PHP。</div></li></ul><li><div>低级语言和高级语言：</div></li><ul><li><div>  低级语言：机器语言，汇编语言和符号语言</div></li><li><div>  高级语言：BASIC，C语言，C++，Pascal，Python，PHP，Ruby，Lua等等</div></li></ul></ul><li><div>编程语言的性质</div></li><ul><li><div>图灵完备性：是针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性。</div></li><ul><li><div>如今主流的编程语言都具有图灵完备性。他们的不同也只是在封装，优化等方面，如果回到这些语言的最底层，就会发现他们可以实现的功能其实完全一样，并且本质上就是一个图灵机。</div></li><li><div>图灵机：图灵机是图灵在1936年发表的“On Computable Numbers，with an Application to the Entscheidungsproblem&quot;(《论可计算数及其在判定性问题上的应用》)中提出的数学模型。在文章中图灵描述了图灵机是一个架空的想法，而非实体概念，并且证明了，只要图灵机可以被实现，就可以用来解决任何可计算的问题。</div></li><ul><li><div>图灵机的结构包括以下几个部分：</div></li><ol><li><div>一条无限长的纸袋(tape)：纸带被分成一个个相邻的格子(square)，每个格子都可以写上至多一个字符(symbol)</div></li><li><div>一个字符表(alphabet)：即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的空白字符(blank)，意思是此格子没有任何字符</div></li><li><div>一个读写头(head)：可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容此外也可以每次向左/右移动一个格子</div></li><li><div>一个状态寄存器(state register)：他追踪每一步运算过程中，整个机器所处的状态(运行/终止)。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。</div></li><li><div>一个有限的指令集(instructions table)：它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南，里面记录着很多条类似鱼“当你身处编号53的格子并看到其内容为0时，擦除，改写为1，并向右移一格。此外，令下一状态为运行。”这样的命令。</div></li></ol><li><div>简单判定图灵完备的方法就是看该语言能否模拟出图灵机</div></li><ul><li><div>图灵不完备的语言常见原因有循环或递归受限，无法实现类似数组或列表这样的数据结构</div></li><li><div>图灵不完备也不是没有意义：有些场景我们需要限制语言本身，如限制循环和递归，可以保证该语言能写的程序一定是终止的。</div></li><li><div>图灵完备也可能带来坏处：如C++的模板语言，模板语言是在类型检查时执行，如果编译器不加以检查，我们完全可以使得C++编译器陷入死循环的程序。</div></li></ul></ul></ul><li><div>动态与静态：</div></li><ul><li><div>动态：Runtime，程序运行期间，在用户的设备/在线服务器上</div></li><li><div>静态：Compile time，在编写程序代码期间，在程序员的设备上，产品开发时。</div></li></ul><li><div>类型系统：在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，如何操作这些类型，这些类型如何互相作用。类型系统在各种语言之间有非常大的不同，最主要的差异在于编译时期的语法，以及运行时期的操作实现方式。</div></li><ul><li><div>编译器可能使用值的静态类型以最优化所需的存储区，并选取对值运算时的较佳算法</div></li><li><div>类型的约束程度以及评估方法，影响了语言的类型。更进一步，编程语言可能就类型多态性的部分，对每一个类型都对应了一个极度个别的算法的运算。</div></li><li><div>类型的基础：定型(typing,又称类型指派)赋予一组比特某个意义。类型通常和存储器中的数值或对象相联系。因为在电脑中，任何数值都是以一组比特简单组成的，硬件无法区分存储器地址，脚本，字符，整数，以及浮点数。类型可以告知程序和程序设计者，应该怎么处理那些比特</div></li><li><div>类型系统提供的主要功能：</div></li><ol><li><div>安全性：使用类型可以允许编译器探测无意义的，或者是可能无效的代码。例如，可以识别出一个无效的表达式&quot;Hello, World&quot; + 3,因为不能对逐字字符串加上一个整数。强类型提供更多的安全性，但它并不能保证绝对安全。</div></li><li><div>最优化：静态类型检查可提供有用的信息给编译器。例如，如果一个类型指明某个值必须以4的倍数对齐，编译器就有可以使用更有效率的机器指令</div></li><li><div>可读性：在更具表现力的类型系统中，若其可以阐明程序设计者的意图的话，类型就可以充当为一种文件形式。例如，时间戳记可以是整数的子类型；但如果程序设计者宣告一个函数为返回一个时间戳记，而不只是一个证书，这个函数就能表现出一部分文件的阐释性</div></li><li><div>抽象化(模块化)类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的低层次实现。例如：程序设计者可以将字符串想成一个值，以此取代仅仅是字节的数组。或者类型允许程序设计者表达两个子系统之间的接口。将子系统间交互时的必要定义加以定位，防止子系统间的通信发生冲突。</div></li></ol><li><div>类型检查：类型检查所进行的检查处理以及实行类型的约束，可发生在编译时期(静态检查)或运行时期(动态检查)。静态检查实在编译器所进行语义分析中进行的。如果一个语言强制实行类型规则称此为强类型，反之为弱类型。</div></li></ul></ul><li><div>一般命令式编程语言的设计方式</div></li><ul><li><div>一般分为五个层级</div></li><ol><li><div>Atom(原子级)：identifier，Literal</div></li><li><div>Expression(表达式)：Atom，Operator，Punctuator</div></li><li><div>Statement(语句)：Expression，Keyword，Punctuator</div></li><li><div>Structure(结构)：function，class，process，Namespace</div></li><li><div>Program(项目)：Program，Module，Package，Library</div></li></ol></ul></ul><div>二，JS类型：七种类型：Number，String，Boolean，Object，Null，Undefined，Symbol。常用的只有前五种。</div><ul><li><div>Number</div></li><ul><li><div>浮点数：浮点数表达法采用了科学计数法来表达实数，即用一个有效数字。一个表示正负的符号，一个指数以及一个基数来表示实数。</div></li><li><div>浮点数表示法：IEEE浮点数标准是从逻辑上用三元组(S, E, M)来表示一个数V的，即V= (-1)S*M*2E</div></li><ul><li><div>符号位S(Sign)决定数是正数(0)还是负数(S=1)，而对于数值0的符号位解释则作为特殊情况处理</div></li><li><div>有效数字位M(Significand)是二进制小数，它的取值范围为 <span style="color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">1~2</span><span style="vertical-align: super; font-size: smaller; font-size: smaller; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">-ε</span><span style="color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">，或者为 0~1</span><span style="vertical-align: super; font-size: smaller; font-size: smaller; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);">-ε</span><span style="color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;, 微软雅黑, &quot;Microsoft Yahei&quot;, Helvetica, Arial, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">。它也被称为尾数位(Mantissa),系数位(Coefficient)，甚至还被称作&quot;小数&quot;</span></div></li><li><div><span style="font-size: 11pt; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;;">指数位E(Exponent)：是2的幂(也可能是负数)，它的作用是对浮点数加权。</span></div></li></ul><li><div><span style="font-size: 11pt; color: rgb(68, 68, 68); font-family: &quot;Helvetica Neue&quot;;">在JavaScript中：0.   与   .1  都表示合法的小数值，只要小数点一面有值即可。但注意：0.toString()会报错，因为会把0.当作0来解析，0. toString 这种是对的</span></div></li></ul><li><div>String：在计算机内部使用的是二进制，只认识0和1，计算机根本不认识文字。但平时交流沟通的是文字，而不是0和1，这样，如果让计算机能够识别文字，就需要将文字存储为数字，然后再将数字转化成文字进行显示，这就相当于编码和解码，这就谈到了编码和解码需要的规则。</div></li><ul><li><div>19世纪60年代，美国委员会制定了ASCII码，使用7个bit来编码一个文字。7个比特能够表示128个值，所以ASCII码有足够的空间来表示大写字母，小写字母以及数字等。</div></li><li><div>19世纪70年代，计算机普及了欧洲，计算机的硬件也得到发展，CPU能够一次处理8个比特，计算机的最小存储单位也变成了8bit(一个字节)。相对于ASCII码还有128-255个码是没有用到的。最开始，IBM用这些128-255的数字表示一些有符号的字字母和希腊字母。但这些字符的表示并没有统一的标准化。</div></li><li><div>19世纪90年代末，创造除了15种不同的字符集，他们使用8个bit表示一个字符，叫做ISO-8859-1，ISO-8859-2,直到ISO-8859-16，中间的ISO-8859-12被废弃了。</div></li><li><div>Unicode的诞生就是给世界上每一个国家的每一个文字都分配到一个独一无二的数字，这个数字就叫做码点(code point)，前127个码点和ASCII一样，128-255基本上和ISO-8859-1的一致，256之后就是其他有符号的字符，880之后是希腊字母，11904之后是中国，日本和韩国字符。</div></li><li><div>随着时间的推移以及字符的扩充，Unicode编码字符集也相应的进行了扩充，他把整个字符集分成了17个平面，每个平面都能放2^16个文字，每一个平面的码点从U+n0000到U+nFFFF结束。n是用0x0到0x10，16进制表示。第一个平面Plane0放置的是最初的UCS-2编码中所定义的文字，叫做基本多文本平面Basic Multilingual Plane(BMP)，基本多文本平面码点的取值范围是0x0000-0xFFFF,其他的16个平面称为补充平面，他们的取值范围从0x10000开始(0xFFFF+1=0x10000,16进制计算)。UCS-2编码方式不适合这种多平面的字符集。此时计算机得到了发展，UTF-16以及UTF-32取代了UCS-2.</div></li><li><div>UTF-16是对于在BMP平面的文字用两个字节(16bit)存储，然后对于其他平面的文字进行四个字节存储</div></li><li><div>UTF-32则是用32个bit，4个字节存储一个字符，所有字符都占用4个字节</div></li><li><div>UTF-16与UTF-32的问题：在进行文件传输的时候，如果你写的都是英文字符，它使用一个字节就够用了，如果使用UTF-16和UTF-32就会浪费带宽。最终出现了UTF-8，解决了这个问题。</div></li><li><div>UTF-8使用的是变长字节。码点从0-127使用一个字节存储，只有码点大于128，才会用2个或3个字节存储，最大使用6个字节。UTF-8可以减少文档大小，不浪费带宽。</div></li><li><div>UTF-16：UTF-16编码介于UTF-8和UTF-32之间，同时结合了定长和变长的两种编码方法的特点。</div></li><ul><li><div>UTF-16的编码规则：基本平面的字符占用了2个字节，辅助平面的字符占用了4个字节。也就是说UTF-16的编码长度要么是2个字节(U+0000到U+FFFF)，要么是4个字节(U+010000到U+10FFFF)</div></li><li><div>奇妙的设计：在基本平面内，从U+D8oo到U+DFFF是一个空段，即这些码点不对应任何字符。因此这个空段可以用来映射辅助平面的字符</div></li><li><div>辅助平面的字符共有2^20个，也就是说，对应这些字符至少需要20个二进制位。UTF-16将这20位拆分为两半，前10位映射在U+D8oo到U+DBFF(空间大小为2^10)，称为高位(H),后10位映射在U+DCoo到U+DFFF(空间大小为2^10)，称为低位(L)。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。<b><font style="color: rgb(77, 206, 29);">所以，当我们遇到两个字节，发现它的码点在U+D8oo到U+DBFF之间，就可以断定，紧跟在后面的两个字节的码点。应该在U+DCoo到U+DFFF之间，这四个字节必须放在一起解读</font></b>。</div></li><li><div>UTF-16的转码方式：Unicode码点转成UTF-16的时候，首先区分 这是基本平面字符还是辅助平面字符。</div></li><ul><li><div><span style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: medium; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">如果是基本平面字符，直接将码点转为对应的16进制形式，长度为2字节。例如：U+597D = 0x597D</span></div></li><li><div>如果是辅助平面字符，Unicode3.0版本给出了转码公式：H = Math.floor((c - 0x10000) / 0x400) + 0xD800，L = (c - 0x10000) % 0x400 + 0xDC00</div></li></ul></ul><li><div>JavaScript语言采用Unicode字符集，但是只支持一种编码方法。<b><font style="color: rgb(250, 122, 0);">JavaScript使用的是UCS-2</font></b>.</div></li><ul><li><div>1995年5月，Brendan Eich用了10天设计了JavaScript语言；10月，第一个解释引擎问世；次年11月，Netscape正式向ECMA提交语言标准。<b><font style="color: rgb(250, 122, 0);">UTF-16的发布时间是1996年7月，</font></b>就会明白Netscape公司那是没有其他选择，只有UCS-2一种编码方法可以使用。</div></li><li><div>UCS-2：1988年成立的Unicode团队和1989年成立的UCS团队在1991年的10月，两个团队决定合并字符集。也就是从今往后只发布一套字符集，就是Unicode，并且修订此前发布的字符集，UCS的码点将与Unicode完全一致。</div></li><li><div>UCS团队开发的进度快于Unicode，<b><font style="color: rgb(250, 122, 0);">1990年发布了第一套编码方法UCS-2</font></b>，使用2个字节表示已经有码点的字符。(那个时候只有一个平面，基本平面，两个字节够用了)。</div></li><li><div>UTF-16编码在1996年才发布，明确宣布是UCS-2的超集，即<b><font style="color: rgb(77, 206, 29);">基本平面字符沿用了UCS-2的编码，辅助平面字符定义了4个字节的表示方法。</font></b></div></li><li><div>UCS-2与UTF-16的关系：UTF-16取代了UCS-2，或者说UCS-2整合进了UTF-16。所以现在只有UTF-16，没有UCS-2</div></li><li><div>JavaScript字符函数的局限：由于JavaScript只能处理UCS-2编码，造成所有字符在这门语言中都是2个字节，如果是4个字节的字符，会当作两个双字节的字符处理。JavaScript采用Unicode字符集。只支持16位的UTF-16编码，不支持32位。例如：JavaScript会把UTF-16编码是4字节的0xD834,0xDFo6看作单独的两个字符U+D834和U+DFo6。而这两个码点是空的。所以，需要手动调整对码点进行一个判断。<b><font style="color: rgb(77, 206, 29);">所以，JavaScript的字符处理函数只对2字节的码点有效，如果要正确处理4字节的码点，就必须逐一部署自己的版本，判断当前字符的码点</font></b>。</div></li><li><div>JavaScript的ES6版本：大大增强了对Unicode的支持，基本上解决了以上的问题。</div></li><ul><li><div>ES6版本允许直接用码点表示Unicode字符，写法是“反斜杠+u+码点”：例如：‘好’=== ‘\u597D’//true</div></li><li><div>但是这种表示法对4字节的码点无效。ES6修正了这个问题，只要将码点放在大括号内，就能正确识别。</div></li><li><div>ES6新增的字符串处理函数(专门处理4字节码点)：</div></li><ol><li><div>String.fromCodePoint():从Unicode码点返回对应字符</div></li><li><div>String.prototype,codePointAt()：从字符返回对应的码点</div></li><li><div>String.prototype.at()：返回字符串给定位置的字符</div></li></ol></ul></ul></ul><li><div>其他类型</div></li><ul><li><div>Boolean：true，false</div></li><li><div>Null：关键字，有值，但为空，赋值会发生错误</div></li><li><div>Undefined：不是关键字，没有值，可以赋值。最安全得到undefined的方法是void 0</div></li><li><div>Symbol：与在对象中的String类似，都是描述对象的属性名，但是一个对象中不可能有两个相同的Symbol。</div></li></ul><li><div>对象的基础知识：在计算机科学中，对象，台湾译作物件，是一个存储器地址，其中拥有值，这个地址可能有标识符指向此处。对象可以是一个变量，一个数据结构或者是一个函数。</div></li><ul><li><div>在软件系统中，对象具有唯一的标识符，对象包括属性和方法，属性就是需要记忆的信息，方法就是对象能够提供的服务。在面向对象的软件中，对象是一个类的实例。</div></li><li><div>对象的状态是由行为决定的。状态不可能改变行为。</div></li><li><div>类：类是一种常见的描述对象的方式。</div></li><li><div>原型：原型是一种更接近人类原始认知的描述对象的方法</div></li><li><div>对象三要素：唯一的标识符，状态，行为(可以改变状态的行为)</div></li><li><div>在设计对象的状态和行为时，我们总是遵循“行为改变状态的原则”</div></li></ul><li><div>JS中的对象</div></li><ul><li><div>两个要素：属性和原型</div></li><li><div>属性查找的规则按照原型链的机制查询</div></li><li><div>属性分为数据属性(一般描述状态)和访问器属性(一般是描述行为)</div></li><li><div>特殊对象</div></li><ul><li><div>函数对象：函数对象也具有一个行为[[call]]，我们用JavaScript中的function关键字，箭头运算符或者Function构造器创建的对象，都会有[[call]]这个行为。如果对应的对象没有[[call]]行为，就会报错。这种特殊行为在外部是无论如何访问不到的。可以用类似f()这样的语法把对象当作函数调用时，会访问到[[call]]这个行为。</div></li><li><div>Array：Array的length属性根据最大的下标自动发生变化</div></li><li><div>Object.prototype：作为所有正常对象的默认原型，它的原型是null，给它设置原型会报错</div></li><li><div>String：为了支持下标运算，string的正整数属性访问会去字符串里查找</div></li><li><div>arguments：arguments的非负整数型下标属性跟对应的变量联动</div></li><li><div>模块的namespace对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于import</div></li><li><div>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊</div></li><li><div>bind后的function：跟原来的函数相关联</div></li></ul></ul></ul><div><br/></div><div><br/></div><div><b><font style="font-size: 14pt; color: rgb(250, 122, 0);">参考的文献：</font></b></div><ul><li><div><b><font style="font-size: 10pt;">巴科斯范式--维基百科<a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F"><font style="color: rgb(26, 173, 224);">https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F</font></a></font></b></div></li></ul><ul><li><div><b><font style="font-size: 10pt;">计算机编程语言的分类--滴水石穿CSDN<a href="https://blog.csdn.net/zhanggaofeixy/article/details/52180048"><font style="color: rgb(26, 173, 224);">https://blog.csdn.net/zhanggaofeixy/article/details/52180048</font></a></font></b></div></li><li><div><b><font style="font-size: 10pt;">计算机语言的分类--掘金<a href="https://juejin.im/post/5b1507d5e51d45067d40688d"><font style="color: rgb(26, 173, 224);">https://juejin.im/post/5b1507d5e51d45067d40688d</font></a></font></b></div></li><li><div><b><font style="font-size: 10pt;">一图看懂编程语言的分类--斜杠老A CSDN<a href="https://blog.csdn.net/acelit/article/details/62466679"><font style="color: rgb(26, 173, 224);">https://blog.csdn.net/acelit/article/details/62466679</font></a></font></b></div></li><li><div><font style="font-size: 10pt;"><b><font>什么是图灵完备？--知乎</font></b><a href="https://www.zhihu.com/question/20115374"><b><font style="color: rgb(26, 173, 224);">https://www.zhihu.com/question/20115374</font></b></a></font></div></li><li><div><b><font style="font-size: 10pt;"><font>类型系统--维基百科</font><a href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1"><font style="color: rgb(26, 173, 224);">https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1</font></a></font></b></div></li><li><div><font style="font-size: 10pt;"><span style="font-weight: bold;">IEEE 754浮点数标准详解--C语言中文网</span><a href="http://c.biancheng.net/view/314.html" style="font-weight: bold; color: rgb(26, 173, 224);">http://c.biancheng.net/view/314.html</a></font></div></li><li><div><font style="font-size: 10pt;"><span style="font-weight: bold;">浮点数--GitHub</span><a href="https://akaedu.github.io/book/ch14s04.html" style="font-weight: bold; color: rgb(26, 173, 224);">https://akaedu.github.io/book/ch14s04.html</a></font></div></li></ul><ul><li><div><b><font style="font-size: 10pt;">Unicode与JavaScript详解--阮一峰<a href="https://www.ruanyifeng.com/blog/2014/12/unicode.html"><font style="color: rgb(26, 173, 224);">https://www.ruanyifeng.com/blog/2014/12/unicode.html</font></a></font></b></div></li><li><div><b><font style="font-size: 10pt;">Unicode和JS中的字符串--SamWeb<a href="https://www.cnblogs.com/SamWeb/p/13113009.html"><font style="color: rgb(26, 173, 224);">https://www.cnblogs.com/SamWeb/p/13113009.html</font></a></font></b></div></li></ul></div><div><br/></div></span>
</div></body></html> 